package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"strings"
	"testing"
)

func readfile(s string) ([]byte, error) {
	f, err := os.Open(s)
	if err != nil {
		return nil, err
	}

	blob, err := ioutil.ReadAll(f)
	f.Close()
	return blob, err
}

func TestUnMarshal(t *testing.T) {
	cmd := exec.Command("testdata/gentests.py")
	err := cmd.Run()
	if err != nil {
		t.Fatal(err)
	}

	files, err := ioutil.ReadDir(".")
	if err != nil {
		t.Fatal(err)
	}

	testcases := 0
	for _, file := range files {
		if !strings.HasSuffix(file.Name(), ".pickle") {
			continue
		}

		testcases++
		base := file.Name()[:len(file.Name())-7]
		t.Logf("Testing %s", base)
		pickle, err := readfile(fmt.Sprintf("%s.pickle", base))
		if err != nil {
			t.Error(err)
			continue
		}
		blob, err := readfile(fmt.Sprintf("%s.line", base))
		if err != nil {
			t.Error(err)
			continue
		}
		lines := strings.Split(string(blob), "\n")
		for i := 0; i < len(lines); {
			if strings.TrimSpace(lines[i]) == "" {
				// delete element, preserve order
				lines = append(lines[:i], lines[i+1:]...)
			} else {
				i++
			}
		}

		// Actually run our code
		decode := decodePickle(pickle)

		// Validation
		for i, s := range lines {
			if i >= len(decode) {
				t.Errorf("Data point not decoded: %s", s)
				continue
			} else {
				t.Logf("Decoded: %s", decode[i])
			}
			if strings.TrimSpace(s) != decode[i] {
				t.Errorf("Graphite line strings don't match:  %s != %s",
					s, strings.TrimSpace(lines[i]))
			}
		}
		os.Remove(fmt.Sprintf("%s.pickle", base))
		os.Remove(fmt.Sprintf("%s.line", base))
	}

	if testcases == 0 {
		t.Fatal("No testcases generated by testdata/gentests.py")
	}
}
